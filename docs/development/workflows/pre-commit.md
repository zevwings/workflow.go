# 提交前检查指南

> 🤖 **AI 工作流文档**：本文档是专为 AI 助手设计的提交前检查工作流指南，提供标准化的检查流程和检查清单，帮助 AI 助手在代码提交前完成必要的检查。
>
> 📋 **快速检查清单**：代码开发完成后、提交代码前需要完成的检查项（5-15分钟）
>
> 🚀 **快速开始**：[跳转到快速检查清单](#-快速检查清单) | [查看快速参考指南](../references/quick-reference.md)

## 📖 相关指南

| 指南类型 | 时间投入 | 使用场景 | 链接 |
|---------|----------|----------|------|
| 🚀 **快速参考** | 1分钟 | 快速查找命令和清单 | [快速参考指南](../references/quick-reference.md) |
| ⚡ **提交前检查** | 5-15分钟 | 日常提交前验证 | 本文档 |
| 🔍 **深入检查** | 2-4小时 | 功能完成后、定期审查 | [检查指南](./review.md) |

### 专门检查指南

- [代码检查指南](../references/review-code.md) - 重复代码、工具复用、第三方库检查
- [测试用例检查指南](../references/review-test-case.md) - 测试覆盖、合理性、缺失测试检查
- [文档完整性检查指南](../references/review-document-completeness.md) - README、架构文档、CHANGELOG 完整性检查
- [架构文档与代码一致性检查指南](../references/review-architecture-consistency.md) - 架构文档与代码一致性检查
- [CLI 检查指南](../references/review-cli.md) - CLI 命令结构、补全脚本检查

---

## 📋 快速导航

### 🎯 核心检查（必做）
- [⚡ 快速检查清单](#-快速检查清单) - 1分钟了解核心命令
- [✅ 代码质量检查](#-代码质量检查) - 格式化、golangci-lint、编译
- [🧪 测试用例检查](#-测试用例检查) - 运行测试、检查覆盖
- [🔎 版本管理检查](#61-版本管理) - 版本号更新验证

### 📚 详细检查（按需）
- [📚 文档检查](#-文档检查) - README、架构文档更新
- [🔧 CLI 检查](#-cli-和-completion-检查) - 命令注册、补全脚本
- [🔍 代码优化检查](#-代码优化检查) - 重复代码、工具复用
- [🔎 其他检查项](#-其他检查项) - 依赖、性能、安全等

### 📄 报告和帮助
- [📄 生成检查报告](#-生成检查报告) - 创建检查记录
- [❓ 常见问题](#-常见问题) - 故障排除指南

---

## 🚀 检查步骤

### 📊 检查流程图

```mermaid
graph TD
    A[🚀 开始提交前检查] --> B[📋 准备检查环境]

    B --> C{🔍 是否有功能性变更?}
    C -->|是| D[📊 版本检查]
    C -->|否| E[✅ 代码质量检查]

    D --> D1[📝 检查版本号（代码/标签）]
    D --> D2[📚 检查 CHANGELOG.md 更新]
    D1 --> E
    D2 --> E

    E --> E1[🎨 代码格式化检查]
    E --> E2[🔍 golangci-lint 警告检查]
    E --> E3[🔨 编译检查]

    E1 --> F[🧪 测试执行]
    E2 --> F
    E3 --> F

    F --> F1[🧪 单元测试]
    F --> F2[🔧 集成测试]
    F --> F3[📚 文档测试]
    F --> F4[🔧 补全完整性测试]

    F1 --> G{📊 所有检查通过?}
    F2 --> G
    F3 --> G
    F4 --> G

    G -->|是| H[📄 生成检查报告]
    G -->|否| I[❌ 修复问题]

    I --> J{🔄 继续检查?}
    J -->|是| E
    J -->|否| K[⏸️ 暂停提交]

    H --> L[✅ 检查完成]
    L --> M[🎉 准备提交]

    style A fill:#e1f5fe
    style G fill:#f3e5f5
    style H fill:#e8f5e8
    style I fill:#ffebee
    style M fill:#c8e6c9
    style K fill:#fff3e0
```

### 📋 详细检查步骤

按照以下步骤依次完成检查：

### 第一步：CLI 和 Completion 检查

检查 CLI 命令结构和补全脚本：
- CLI 命令注册和参数定义
- 补全脚本完整性测试
- 补全脚本优化

**对应章节**：[CLI 和 Completion 检查](#-cli-和-completion-检查)

### 第二步：代码优化检查

检查代码是否已优化：
- 共用代码提取（参数、工具函数、错误处理）
- 代码重复检查
- 工具函数复用
- 配置管理

**对应章节**：[代码优化检查](#-代码优化检查)

### 第三步：测试用例检查

检查测试覆盖：
- 单元测试
- 集成测试
- 文档测试
- 测试数据和边界情况
- 测试冗余检查（重复测试、过时测试、无效测试）

**对应章节**：[测试用例检查](#-测试用例检查)

### 第四步：代码质量检查

检查代码质量：
- 代码格式化
- golangci-lint 警告
- 编译检查
- 导入语句和顺序
- 自动修复

**对应章节**：[代码质量检查](#-代码质量检查)

### 第五步：文档检查

检查所有文档是否已更新，包括：
- README.md 命令清单和版本号
- 架构文档更新
- 文档索引更新
- 迁移文档（如有需要）

**对应章节**：[文档检查](#-文档检查)

### 第六步：其他检查项

检查其他重要项：
- 版本管理
- 依赖管理
- 平台兼容性
- 性能检查
- 安全性检查
- 用户体验

**对应章节**：[其他检查项](#-其他检查项)

### 最后：生成检查报告

完成所有检查后，生成检查报告文档。

**对应章节**：[生成检查报告](#-生成检查报告)

---

## 🎯 检查概述

> ⚡ **快速质量保障**：提交前快速检查，确保代码质量和基本规范

### 🎯 检查目标

| 目标 | 描述 | 输出 |
|------|------|------|
| ✅ **代码质量** | 格式化、golangci-lint、编译检查 | 无错误和警告 |
| 🧪 **测试通过** | 单元测试、集成测试、文档测试 | 所有测试通过 |
| 📚 **文档更新** | README、架构文档、版本号 | 文档同步更新 |
| 🔧 **CLI 完整性** | 命令注册、补全脚本 | 补全脚本测试通过 |

### 📊 检查范围

| 领域 | 检查内容 | 时间估算 | 专门指南 |
|------|----------|----------|----------|
| ✅ **代码质量** | 格式化、golangci-lint、编译 | 2-5分钟 | - |
| 🧪 **测试** | 运行测试、检查覆盖 | 3-8分钟 | [测试用例检查指南](../references/review-test-case.md) |
| 📚 **文档** | README、架构文档 | 2-5分钟 | [文档完整性检查指南](../references/review-document-completeness.md) |
| 🔧 **CLI** | 命令注册、补全脚本 | 2-5分钟 | [CLI 检查指南](../references/review-cli.md) |
| 🔍 **代码优化** | 重复代码、工具复用 | 5-10分钟（可选） | [代码检查指南](../references/review-code.md) |

---

## 📚 文档检查

> **详细检查指南**：本文档提供快速检查清单，如需进行系统性的文档完整性检查，请参考 [文档完整性检查指南](../references/review-document-completeness.md)，该指南包含完整的检查流程、检查方法和示例。如需进行架构文档与代码一致性检查，请参考 [架构文档与代码一致性检查指南](../references/review-architecture-consistency.md)。

### 快速检查清单

**检查项**：
- [ ] README.md 命令清单和版本号是否已更新
- [ ] 架构文档与代码实现一致（如适用，参考 [架构文档与代码一致性检查指南](../references/review-architecture-consistency.md)）
- [ ] 架构文档是否已更新（`docs/architecture/`）
- [ ] 文档索引是否已更新（`docs/README.md`）
- [ ] 迁移文档是否已创建（如有破坏性变更）

### 详细检查项

#### 1.1 README.md 更新

**检查项**：
- [ ] 命令清单部分是否已更新新增/修改的命令
- [ ] 架构总览部分是否反映了架构变更
- [ ] 快速开始部分是否准确
- [ ] 版本号是否与代码中定义的版本一致

**位置**：`README.md`

#### 1.2 架构文档更新

**检查项**：
- [ ] 相关架构文档是否已更新（`docs/architecture/{module}.md`，包含 Lib 层和 Commands 层）
- [ ] `cli.md` 是否反映了命令结构变更
- [ ] `completion.md` 是否反映了补全相关变更

**位置**：`docs/architecture/`

#### 1.3 文档索引更新

**检查项**：
- [ ] 新增文档是否已添加到 `docs/README.md` 索引

**位置**：`docs/README.md`

#### 1.4 迁移文档

**检查项**：
- [ ] 如有破坏性变更，是否已创建迁移指南（`docs/migration/`）
- [ ] 版本号是否正确

### 更多检查项

详细的文档检查包括但不限于：
- 文档完整性检查（README.md、docs/ 目录、CHANGELOG.md）
- 重复内容检查（跨文档重复、文档内部重复）
- 文档位置检查（文档分类、命名规范）
- 文档优化和补全检查（内容完整性、准确性、格式规范性、可读性、链接有效性）

**参考**：[文档完整性检查指南](../references/review-document-completeness.md) 获取完整的检查方法和示例。

---

## 🔧 CLI 和 Completion 检查

> **详细检查指南**：本文档提供快速检查清单，如需进行系统化的 CLI 和 Completion 检查，请参考 [CLI 检查指南](../references/review-cli.md)，该指南包含完整的检查流程、参数复用检查、参数提取指南和自动化检查工具。

### 快速检查清单

**检查项**：
- [ ] 新增命令是否已在 `root.go` 中注册（`internal/cli/root.go`）
- [ ] 命令文档注释（`//`）是否完整
- [ ] 参数文档注释是否完整
- [ ] 参数命名是否一致（如 `jiraID` vs `jiraTicket`）
- [ ] 运行测试确保补全脚本正常工作
- [ ] 新增命令是否包含在补全脚本中
- [ ] 重复参数是否已提取为共用参数结构（出现 2+ 次必须提取）
- [ ] 是否使用嵌入结构体复用参数

**测试命令**：
```bash
# 运行 CLI 相关测试
go test ./internal/cli/...

# 手动生成补全脚本验证
go run ./cmd/workflow completion bash
go run ./cmd/workflow completion zsh
```

**位置**：
- CLI 命令定义：`internal/cli/`
- 共用参数定义：`internal/lib/cli/args.go`（如适用）
- 命令实现：`internal/commands/`

**参考**：
- [CLI 检查指南](../references/review-cli.md) - 完整的检查方法和参数提取指南
- [代码优化检查 - 提取共用参数](#提取共用参数)

---

## 🔍 代码优化检查

> **详细检查指南**：本文档提供快速检查清单，如需进行系统性的代码检查，请参考 [代码检查指南](../references/review-code.md)，该指南包含完整的检查流程、10 种重复代码模式检查、已封装工具清单和第三方工具检查方法。

### 快速检查清单

**检查项**：
- [ ] 共用代码是否已提取（参数、工具函数、错误处理）
- [ ] 代码重复是否已消除
- [ ] 工具函数是否已复用
- [ ] 配置管理是否统一
- [ ] **避免过度设计**：代码是否简洁实用，没有不必要的抽象层

### 基本检查项

#### 3.1 共用代码提取

**检查项**：
- [ ] 共用参数是否已提取为共用结构体（如 `OutputFormatArgs`、`DryRunArgs`）
- [ ] 共用工具函数是否已提取到 `helpers.go` 模块（如适用）
- [ ] 错误处理是否统一使用 `fmt.Errorf` 和 `%w` 动词

**参考**：见 [代码检查指南 - 重复代码检查](../references/review-code.md#-重复代码检查) 获取详细的提取方法和示例。

#### 3.2 代码重复检查

**检查项**：
- [ ] 输出格式处理逻辑是否已提取
- [ ] 参数解析逻辑是否可复用
- [ ] 文件操作是否使用共用工具（`internal/lib/util`）
- [ ] HTTP 请求是否统一使用 `HttpClient`
- [ ] Git 操作是否统一使用 `internal/lib/git` 模块

**工具函数位置**：
- `internal/lib/util/` - 通用工具函数
- `internal/lib/prompt/` - 交互式对话框
- `internal/lib/output/` - 输出格式化工具
- `internal/commands/*/helpers.go`（如适用） - 命令特定帮助函数

#### 3.3 工具函数复用

**检查项**：
- [ ] 是否使用 `internal/lib/util` 中的工具函数
- [ ] 是否使用 `internal/lib/prompt` 进行用户交互
- [ ] 是否使用 `internal/lib/output` 显示输出

**参考**：见 [代码检查指南 - 已封装工具检查](../references/review-code.md#️-已封装工具检查) 获取完整的工具函数清单和使用方法。

#### 3.4 配置管理

**检查项**：
- [ ] 是否使用 `Settings` 统一管理配置
- [ ] 是否使用 `Paths` 统一管理路径
- [ ] 配置验证是否统一

#### 3.5 避免过度设计

**检查原则**：
- **YAGNI（You Aren't Gonna Need It）**：不要为未来可能的需求添加功能
- **KISS（Keep It Simple, Stupid）**：保持简单，避免不必要的复杂性
- **实用主义**：优先满足当前需求，避免过度抽象

**检查项**：
- [ ] 是否有为单一实现创建的 trait？是否可以简化为直接实现？
- [ ] 是否有不必要的抽象层？是否可以减少中间层？
- [ ] 是否有为未来需求添加的功能？是否可以移除？
- [ ] 是否有过度封装的简单函数？是否可以简化为直接函数调用？
- [ ] 代码复杂度是否与实际需求匹配？
- [ ] 是否使用了不必要的设计模式？
- [ ] 是否有不必要的泛型参数？

**常见过度设计模式**：
- ❌ 为单一实现创建 trait
- ❌ 创建多层抽象但只有一层实现
- ❌ 为简单场景使用复杂的设计模式
- ❌ 为未来可能的需求添加功能
- ❌ 创建过于灵活的配置系统但实际只需要简单配置
- ❌ 将简单函数包装成复杂的结构体

**示例**：
```go
// ❌ 过度设计：为单一实现创建接口
type FileReader interface {
    Read(path string) (string, error)
}

// ✅ 简洁设计：直接使用函数
func ReadFile(path string) (string, error) {
    data, err := os.ReadFile(path)
    if err != nil {
        return "", fmt.Errorf("failed to read file: %w", err)
    }
    return string(data), nil
}
```

### 更多检查项

详细的代码检查包括但不限于：
- **10 种重复代码模式检查**：文件操作、Git 命令、错误处理、字符串处理、路径处理、HTTP 请求、配置读取、日志输出、用户交互、进度指示器
- **已封装工具检查**：文件操作工具、字符串处理工具、格式化工具、平台检测工具、浏览器和剪贴板工具、解压和校验和工具、日期格式化工具、表格输出工具、Git 操作工具、HTTP 客户端工具、日志工具、对话框工具、进度指示器工具、配置管理工具
- **第三方工具检查**：正则表达式处理、JSON 处理、TOML 处理、命令行参数解析、异步处理、并发处理、时间处理、路径处理、环境变量处理、错误处理
- **过度设计检查**：不必要的抽象层、过度封装、过早优化、不必要的复杂性

**参考**：[代码检查指南](../references/review-code.md) 获取完整的检查方法、搜索模式和示例分析。

---

## 🧪 测试用例检查

> **详细检查指南**：本文档提供快速检查清单，如需进行系统性的测试用例检查，请参考 [测试用例检查指南](../references/review-test-case.md)，该指南包含完整的检查流程、测试覆盖情况分析、测试用例合理性检查和缺失测试用例识别方法。

### 快速检查清单

**检查项**：
- [ ] 单元测试是否覆盖新增功能
- [ ] 集成测试是否覆盖主要流程
- [ ] 测试是否全部通过
- [ ] 测试冗余是否已清理

### 基本检查项

#### 4.1 单元测试

**检查项**：
- [ ] 新增功能是否有对应的单元测试
- [ ] 边界情况是否已覆盖
- [ ] 错误处理是否已测试

**位置**：与源代码在同一文件中（`#[cfg(test)]` 模块）

**运行测试**：
```bash
# 运行所有测试（包括单元测试、集成测试和文档测试）
make test
# 或
go test -v ./...

# 运行特定测试
go test ./internal/cli/...    # CLI 相关测试
go test ./internal/commands/...  # 命令测试
go test ./internal/lib/...    # 库测试
```

#### 4.2 集成测试

**检查项**：
- [ ] CLI 命令是否在 `test/cli/` 中有测试
- [ ] 补全完整性测试是否通过（`internal/cli/*_test.go`）
- [ ] 集成测试是否覆盖主要流程（`test/integration/`）

**位置**：`test/` 目录或 `*_test.go` 文件

#### 4.3 测试覆盖率

**检查项**：
- [ ] 运行 `make test` 或 `go test -v ./...` 确保所有测试通过
- [ ] 新增代码路径是否被测试覆盖
- [ ] 测试用例命名是否清晰（`Test*`）
- [ ] 文档中的代码示例（doctest）是否能够正常编译和运行

#### 4.4 测试数据

**检查项**：
- [ ] 测试 fixtures（`tests/fixtures/`）是否需要更新
- [ ] Mock 数据是否准确

#### 4.5 测试冗余检查

**检查项**：
- [ ] 是否存在重复的测试用例（测试相同功能或相同代码路径）
- [ ] 是否有过时或不再需要的测试（功能已移除或重构，但测试未更新）
- [ ] 测试是否真正有效（是否测试了正确的功能，断言是否正确）
- [ ] 是否有测试用例测试了已不存在的代码路径（代码已删除但测试仍存在）
- [ ] 是否有测试用例测试了已废弃的 API 或方法

**检查方法**：
```bash
# 搜索测试文件，查找相似的测试用例
grep -r "func Test" . -name "*_test.go" | sort | uniq -d
```

### 更多检查项

详细的测试用例检查包括但不限于：
- **测试覆盖情况检查**：模块覆盖检查、功能覆盖检查、覆盖率评估（总体覆盖率、核心模块覆盖率、工具模块覆盖率、CLI 层覆盖率）
- **测试用例合理性检查**：测试工具使用检查（参数化测试、断言工具、快照测试、Mock 测试）、测试结构检查（AAA 模式、测试组织、测试数据管理）、测试内容检查（成功路径测试、错误路径测试、边界条件测试、集成测试）
- **缺失测试用例检查**：缺失模块测试识别、缺失功能测试识别、缺失测试类型识别（错误路径测试、边界条件测试、集成测试）

**参考**：[测试用例检查指南](../references/review-test-case.md) 获取完整的检查方法、检查报告格式和示例输出。

---

## ✅ 代码质量检查

### 5.1 格式化检查

**命令**：
```bash
make fmt
# 或
go fmt ./...

# 检查格式（CI/CD）
gofmt -l .
```

**检查项**：
- [ ] 代码格式是否符合 Go 官方风格
- [ ] 缩进是否统一（使用 tab）
- [ ] 导入语句是否已整理（使用 `goimports`）

**自动修复**：
```bash
go fmt ./...
goimports -w .
```

### 5.2 golangci-lint 检查

**命令**：
```bash
make lint
# 或
golangci-lint run
```

**检查项**：
- [ ] 所有 golangci-lint 警告是否已修复
- [ ] 是否遵循项目 Lint 规则（`.golangci.yml`）
- [ ] 是否处理了所有错误（不使用 `_` 忽略错误）

**自动修复**：
```bash
golangci-lint run --fix
```

### 5.3 编译检查

**命令**：
```bash
go build ./...
```

**检查项**：
- [ ] 代码是否能够编译通过
- [ ] 是否有未使用的导入或变量
- [ ] 类型是否匹配

### 5.4 导入检查

**检查项**：
- [ ] 所有导入是否统一从文件顶部导入
- [ ] 平台特定的导入是否使用构建标签 `//go:build` 标记
- [ ] 导入语句是否按标准库、第三方库、项目内部的顺序组织
- [ ] 是否使用 `goimports` 自动管理导入

**正确示例**：
```go
// 文件顶部统一导入
package config

import (
    // 标准库
    "fmt"
    "os"
    "path/filepath"

    // 第三方库
    "github.com/spf13/cobra"

    // 项目内部
    "github.com/zevwings/workflow/internal/lib/config"
)
```

**错误示例**：
```go
// ❌ 错误：导入顺序混乱
package config

import (
    "github.com/zevwings/workflow/internal/lib/config"  // 应该在最后
    "fmt"  // 应该在前面
)
```

**导入顺序规范**：
1. 标准库导入（`fmt`, `os`, `path/filepath` 等）
2. 第三方库导入（按字母顺序）
3. 项目内部导入（`github.com/zevwings/workflow/...`）

**平台特定导入**：
- 使用构建标签 `//go:build` 标记平台特定代码
- 平台特定的导入应放在对应的平台特定文件中

**示例**：
```go
//go:build windows

package config

import (
    "os"
    "path/filepath"
)
```

### 5.5 自动修复

**命令**：
```bash
make fmt
make lint
# 或手动执行：
go fmt ./...
goimports -w .
golangci-lint run --fix
```

**检查项**：
- [ ] 运行自动修复后是否还有问题
- [ ] 自动修复后的代码是否仍需手动调整

---

## 🔎 其他检查项

### 6.1 版本管理

#### 6.1.1 判断是否需要更新版本号

**检查场景**：
- 新增功能（feat）→ 需要更新版本号（minor 或 patch）
- Bug 修复（fix）→ 需要更新版本号（patch）
- 重构（refactor）→ 通常不需要更新版本号（除非影响 API）
- 文档更新（docs）→ 不需要更新版本号
- 代码风格（style）→ 不需要更新版本号
- 测试（test）→ 不需要更新版本号
- 构建/工具（chore、ci）→ 不需要更新版本号

**判断依据**：
1. **功能性变更**：如果提交包含了新功能或修复了 bug，需要更新版本号
2. **用户可见变更**：如果变更会影响用户使用，需要更新版本号
3. **API 变更**：如果变更了公共 API，需要更新版本号
4. **发布周期**：如果计划发布新版本，需要更新版本号

**版本号规则**（遵循语义化版本）：
- **Major (x.0.0)**：破坏性变更（BREAKING CHANGE）
- **Minor (x.x.0)**：新功能，向后兼容（feat）或 patch >= 9
- **Patch (x.x.x)**：Bug 修复和小改进（fix、perf）

#### 6.1.2 检查版本号是否已更新

**快速检查命令**：
```bash
# 检查代码中定义的版本号（通常在 internal/cli/root.go 或 main.go）
grep -r "version.*=" internal/cli/ cmd/workflow/

# 或检查最近一次提交中的版本变更
git diff HEAD~1 HEAD -- internal/cli/ cmd/workflow/ | grep -i version
```

**详细检查清单**：
- [ ] 代码中定义的版本号是否已更新（通常在 `internal/cli/root.go` 或 `cmd/workflow/main.go`）
- [ ] `CHANGELOG.md` 是否已添加新版本记录
- [ ] `README.md` 中的版本示例是否已更新（可选）
- [ ] 版本号是否符合语义化版本规范
- [ ] 新版本号是否已正确递增
- [ ] Git 标签是否已创建（如适用）

**检查方法**：

1. **检查代码中的版本号**：
```bash
# 查看当前版本定义
grep -r "version.*=" internal/cli/ cmd/workflow/

# 查看版本变更
git diff master -- internal/cli/ cmd/workflow/ | grep -i version
```

2. **检查 Git 标签**：
```bash
# 查看最新标签
git tag -l | tail -5

# 验证标签是否存在
git describe --tags
```

3. **检查 CHANGELOG.md**：
```bash
# 查看最新版本记录
head -30 CHANGELOG.md

# 验证版本格式
grep "\[.*\] - 20" CHANGELOG.md | head -5
```

4. **检查 README.md**（可选）：
```bash
# 查看版本号引用
grep -n "VERSION=v" README.md
grep -n "version.*1\." README.md
```

**常见问题**：

1. **忘记更新版本号**：
   - 问题：代码中定义了版本号，但忘记更新
   - 解决：在 `internal/cli/root.go` 或相应位置更新版本号

2. **CHANGELOG.md 未更新**：
   - 问题：版本号已更新，但 CHANGELOG.md 未添加新版本记录
   - 解决：将 `[Unreleased]` 内容移到新版本记录

3. **版本号递增错误**：
   - 问题：版本号跳跃或递增错误（如 1.6.3 → 1.6.5）
   - 解决：按照语义化版本规范正确递增

**示例**：

正确的版本更新应该包含以下文件：
```bash
$ git status
modified:   internal/cli/root.go  # 版本号 1.6.3 → 1.6.4
modified:   CHANGELOG.md    # 添加 [1.6.4] 记录
modified:   README.md       # 更新版本示例（可选）
```

**提示**：
- 如果不确定是否需要更新版本号，可以先提交到特性分支，由 code review 确认
- 版本号更新应该在功能完成后、合并到 master 前进行
- GitHub Actions 可以根据代码中的版本号自动创建 tag 和 release（如已配置）

### 6.2 依赖管理

**检查项**：
- [ ] 新增依赖是否必要
- [ ] 依赖版本是否合理
- [ ] 是否有安全漏洞（可运行 `govulncheck ./...`）

### 6.3 平台兼容性

**检查项**：
- [ ] 是否考虑了跨平台兼容性（macOS/Linux/Windows）
- [ ] 平台特定代码是否使用了构建标签（`//go:build`）
- [ ] 是否测试了不同平台

**示例**：
```go
//go:build darwin
// +build darwin

func GetSystemProxy() (string, error) {
    // macOS 特定实现
}

//go:build linux
// +build linux

func GetSystemProxy() (string, error) {
    // Linux 特定实现
}
```

### 6.4 性能检查

**检查项**：
- [ ] 是否有明显的性能问题（如不必要的克隆、重复计算）
- [ ] 大文件处理是否使用了流式处理
- [ ] 网络请求是否使用了重试机制

### 6.5 安全性检查

**检查项**：
- [ ] 敏感信息（API keys、tokens）是否硬编码
- [ ] 文件操作是否检查了路径安全性
- [ ] 用户输入是否进行了验证

### 6.6 用户体验

**检查项**：
- [ ] 错误消息是否对用户友好
- [ ] 进度提示是否清晰
- [ ] 帮助信息是否完整（`--help`）

---

## 📄 生成检查报告

完成所有检查步骤后，需要生成检查报告文档。

### 报告位置

**文件路径**：`report/pre-commit-report-{timestamp}.md`

其中 `{timestamp}` 为当前日期和时间，格式为 `YYYY-MM-DD_HH-MM-SS`（如：`2024-12-19_14-30-00`）。

**生成带时间戳的文件名**：

在 Go 代码中（自动获取当前时间）：
```go
import (
    "time"
    "fmt"
)

// 函数会自动获取当前时间，无需提前获取
func FormatFilenameTimestamp() string {
    return time.Now().Format("2006-01-02_15-04-05")
}

timestamp := FormatFilenameTimestamp()
reportPath := fmt.Sprintf("report/pre-commit-report-%s.md", timestamp)
// 输出：report/pre-commit-report-2024-12-19_14-30-00.md
```

> **注意**：`FormatFilenameTimestamp()` 函数会在调用时自动获取当前系统时间，无需提前获取。每次调用都会返回最新的时间戳。

在命令行中（手动获取当前时间）：
```bash
# Unix/macOS/Linux
TIMESTAMP=$(date +%Y-%m-%d_%H-%M-%S)
echo "report/pre-commit-report-${TIMESTAMP}.md"

# Windows PowerShell
$timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
Write-Host "report/pre-commit-report-${timestamp}.md"
```

**示例文件名**：`report/pre-commit-report-2024-12-19_14-30-00.md`

### 报告内容

检查报告应包含以下内容：

#### 1. 检查概览

- 检查日期和时间
- 检查人员
- 检查范围（本次提交涉及的功能/模块）
- **重要**：说明这是快速检查汇总，详细检查请参考单个检查报告

#### 1.1 详细检查报告引用（可选）

如果已生成详细的单个检查报告，应在概览部分引用：

```markdown
> **详细检查报告**：
> - [代码检查报告](../../report/CODE_CHECK_REPORT.md) - 详细的重复代码、已封装工具、第三方工具检查（如已生成）
> - [测试覆盖报告](../../report/TEST_COVERAGE_REPORT.md) - 详细的测试覆盖情况分析（如已生成）
> - [文档检查报告](../../report/DOCUMENT_CHECK_REPORT.md) - 详细的文档完整性、准确性检查（如已生成）
> - [CLI 和 Completion 检查报告](../../report/CODE_REVIEW_CHECK_REPORT.md) - 详细的 CLI 命令结构和补全脚本检查（如已生成）
> - [测试用例检查报告](../../report/TEST_CASE_GUIDELINES_CHECK_REPORT.md) - 详细的测试用例合理性检查（如已生成）
```

**说明**：
- 快速检查汇总报告：提供各检查步骤的概览和关键问题，适合快速了解检查结果
- 详细检查报告：按照专门的检查指南（如 `reviews/review-code.md`）生成的深度检查报告，包含具体的问题位置、代码示例、改进方案等
- 建议：在提交前，先运行快速检查汇总，如果发现问题，再运行相应的详细检查报告获取更多信息

#### 2. 各步骤检查结果

按照检查步骤，记录每个步骤的检查结果：

**第一步：CLI 和 Completion 检查**
- [ ] CLI 命令结构检查结果
- [ ] 补全脚本完整性测试结果
- [ ] 补全脚本优化情况
- 问题记录和修复情况

**第二步：代码优化检查**
- [ ] 共用代码提取情况
- [ ] 代码重复检查结果
- [ ] 工具函数复用情况
- [ ] 配置管理情况
- 问题记录和修复情况

**第三步：测试用例检查**
- [ ] 单元测试覆盖情况
- [ ] 集成测试覆盖情况
- [ ] 文档测试结果
- [ ] 测试数据和边界情况
- [ ] 测试冗余检查结果（重复测试、过时测试、无效测试）
- 问题记录和修复情况

**第四步：代码质量检查**
- [ ] 代码格式化结果
- [ ] golangci-lint 警告检查结果
- [ ] 编译检查结果
- [ ] 导入语句检查结果
- [ ] 自动修复情况
- 问题记录和修复情况

**第五步：文档检查**
- [ ] README.md 更新情况
- [ ] 架构文档更新情况
- [ ] 文档索引更新情况
- [ ] 迁移文档情况
- 问题记录和修复情况

**第六步：其他检查项**
- [ ] 版本管理检查结果
- [ ] 依赖管理检查结果
- [ ] 平台兼容性检查结果
- [ ] 性能检查结果
- [ ] 安全性检查结果
- [ ] 用户体验检查结果
- 问题记录和修复情况

#### 3. 问题汇总

- **P0（必须修复）**：列出所有必须修复的问题
- **P1（建议修复）**：列出所有建议修复的问题
- **P2（可选修复）**：列出所有可选修复的问题

每个问题应包含：
- 问题描述
- 问题位置（文件路径和行号）
- 修复状态（已修复/待修复/已记录）
- 修复方案（如适用）

#### 4. 测试结果汇总

- 单元测试：通过/失败数量
- 集成测试：通过/失败数量
- 文档测试：通过/失败数量
- 补全完整性测试：通过/失败数量
- 总体测试覆盖率（如适用）

#### 5. 代码质量指标

- 代码格式化：通过/失败
- golangci-lint 警告：数量（0 为通过）
- 编译状态：通过/失败
- 代码重复率（如适用）

#### 6. 总结

- 检查完成度（百分比）
- 是否准备好提交（是/否）
- 剩余待办事项
- 建议和备注

### 报告模板

```markdown
# 提交前检查报告

**检查日期**：YYYY-MM-DD HH:MM:SS
**检查人员**：[姓名]
**检查范围**：[本次提交涉及的功能/模块]

---

## 检查概览

[简要描述本次检查的范围和目的]

---

## 各步骤检查结果

### 第一步：CLI 和 Completion 检查

**状态**：✅ 通过 / ⚠️ 部分通过 / ❌ 未通过

**检查项**：
- [x] CLI 命令结构检查结果：[描述]
- [x] 补全脚本完整性测试结果：[描述]
- [x] 补全脚本优化情况：[描述]

**问题记录**：
- [问题描述] - [修复状态] - [修复方案]

---

### 第二步：代码优化检查

**状态**：✅ 通过 / ⚠️ 部分通过 / ❌ 未通过

**检查项**：
- [x] 共用代码提取情况：[描述]
- [x] 代码重复检查结果：[描述]
- [x] 工具函数复用情况：[描述]
- [x] 配置管理情况：[描述]

**问题记录**：
- [问题描述] - [修复状态] - [修复方案]

---

### 第三步：测试用例检查

**状态**：✅ 通过 / ⚠️ 部分通过 / ❌ 未通过

**检查项**：
- [x] 单元测试覆盖情况：[描述]
- [x] 集成测试覆盖情况：[描述]
- [x] 文档测试结果：[描述]
- [x] 测试数据和边界情况：[描述]
- [x] 测试冗余检查结果：[描述]（重复测试、过时测试、无效测试）

**问题记录**：
- [问题描述] - [修复状态] - [修复方案]

---

### 第四步：代码质量检查

**状态**：✅ 通过 / ⚠️ 部分通过 / ❌ 未通过

**检查项**：
- [x] 代码格式化结果：[描述]
- [x] golangci-lint 警告检查结果：[描述]
- [x] 编译检查结果：[描述]
- [x] 导入语句检查结果：[描述]
- [x] 自动修复情况：[描述]

**问题记录**：
- [问题描述] - [修复状态] - [修复方案]

---

### 第五步：文档检查

**状态**：✅ 通过 / ⚠️ 部分通过 / ❌ 未通过

**检查项**：
- [x] README.md 更新情况：[描述]
- [x] 架构文档更新情况：[描述]
- [x] 文档索引更新情况：[描述]
- [x] 迁移文档情况：[描述]

**问题记录**：
- [问题描述] - [修复状态] - [修复方案]

---

### 第六步：其他检查项

**状态**：✅ 通过 / ⚠️ 部分通过 / ❌ 未通过

**检查项**：

#### 6.1 版本管理检查结果

- [x] **是否需要更新版本号**：[是/否] - [判断依据：新功能/bug修复/重构/文档等]
- [x] **代码中版本号**：[原版本] → [新版本] / [未修改]
- [x] **Git 标签状态**：[已创建/未创建/不适用]
- [x] **CHANGELOG.md 更新**：[已添加版本记录/未添加/不适用]
- [x] **README.md 版本示例**：[已更新/未更新/不适用]
- [x] **版本号递增规则**：[符合/不符合] - [major/minor/patch]

**检查命令结果**：
```bash
# 代码中版本检查
$ grep -r "version.*=" internal/cli/ cmd/workflow/
[输出结果]

# Git 标签检查
$ git tag -l | tail -5
[输出结果]

# CHANGELOG.md 最新版本
$ head -30 CHANGELOG.md
[输出结果]
```

#### 6.2 依赖管理检查结果

- [x] 依赖管理检查结果：[描述]

#### 6.3 平台兼容性检查结果

- [x] 平台兼容性检查结果：[描述]

#### 6.4 性能检查结果

- [x] 性能检查结果：[描述]

#### 6.5 安全性检查结果

- [x] 安全性检查结果：[描述]

#### 6.6 用户体验检查结果

- [x] 用户体验检查结果：[描述]

**问题记录**：
- [问题描述] - [修复状态] - [修复方案]

---

## 问题汇总

### P0（必须修复）

- [ ] [问题描述] - [位置] - [修复状态]

### P1（建议修复）

- [ ] [问题描述] - [位置] - [修复状态]

### P2（可选修复）

- [ ] [问题描述] - [位置] - [修复状态]

---

## 测试结果汇总

- **单元测试**：X 通过，Y 失败
- **集成测试**：X 通过，Y 失败
- **文档测试**：X 通过，Y 失败
- **补全完整性测试**：X 通过，Y 失败

---

## 代码质量指标

- **代码格式化**：✅ 通过 / ❌ 失败
- **golangci-lint 警告**：X 个警告
- **编译状态**：✅ 通过 / ❌ 失败

---

## 总结

**检查完成度**：X%

**是否准备好提交**：✅ 是 / ❌ 否

**剩余待办事项**：
- [待办事项 1]
- [待办事项 2]

**建议和备注**：
[其他建议和备注]
```

### 生成报告命令

完成所有检查后，创建或更新报告文件：

```bash
# 创建或更新检查报告
vim report/pre-commit-report-{timestamp}.md
# 或使用其他编辑器
```

### 报告使用

- 报告应保存在 `report/pre-commit-report-{timestamp}.md`
- 报告应在提交代码前完成
- 报告可用于代码审查和问题追踪
- **报告类型说明**：
  - **快速检查汇总报告**（`pre-commit-report-*.md`）：按照本指南模板生成，提供各检查步骤的概览和关键问题
  - **详细检查报告**（`CODE_CHECK_REPORT.md`、`TEST_COVERAGE_REPORT.md` 等）：按照专门的检查指南生成，包含详细的问题分析、代码示例、改进方案等
- **使用建议**：
  - 日常提交前：使用快速检查汇总报告，快速了解检查结果
  - 发现问题时：参考相应的详细检查报告，获取详细的问题分析和改进建议
  - 代码审查时：结合快速汇总和详细报告，全面了解代码质量

---

## ⚡ 快速检查清单

> 🎯 **目标**：5-15分钟完成提交前核心检查
>
> 🚀 **快速执行**：复制下方命令块，一键执行所有检查

### 🔥 一键检查命令

```bash
# 📋 完整检查流程（复制执行）
echo "🚀 开始提交前检查..."
echo ""

# 1️⃣ 代码质量检查
echo "🎨 [进行中...] 代码质量检查"
if make lint > /dev/null 2>&1; then
    echo "🎨 [✅ 通过] 代码质量检查 - 格式化和 golangci-lint 检查通过"
else
    echo "🎨 [❌ 失败] 代码质量检查 - 请运行 'make fix' 修复"
    exit 1
fi

# 2️⃣ 运行所有测试
echo "🧪 [进行中...] 测试执行"
if make test > /dev/null 2>&1; then
    echo "🧪 [✅ 通过] 测试执行 - 所有测试通过"
else
    echo "🧪 [❌ 失败] 测试执行 - 请检查失败的测试"
    exit 1
fi

# 3️⃣ 补全脚本完整性
echo "🔧 [进行中...] CLI 补全检查"
if go test ./internal/cli/... > /dev/null 2>&1; then
    echo "🔧 [✅ 通过] CLI 补全检查 - CLI 测试通过"
else
    echo "🔧 [❌ 失败] CLI 补全检查 - 请检查命令注册"
    exit 1
fi

# 4️⃣ 编译验证
echo "🔨 [进行中...] 编译验证"
if go build ./... > /dev/null 2>&1; then
    echo "🔨 [✅ 通过] 编译验证 - 代码编译成功"
else
    echo "🔨 [❌ 失败] 编译验证 - 请修复编译错误"
    exit 1
fi

echo ""
echo "🎉 [✅ 完成] 所有必要检查已通过！"
echo "📊 总用时: $(date)"
echo "✅ 代码已准备好提交"
```

### 📊 实时进度显示

执行检查时，您将看到如下进度显示：

```
🚀 开始提交前检查...

🎨 [进行中...] 代码质量检查
🎨 [✅ 通过] 代码质量检查 - 格式化和 golangci-lint 检查通过

🧪 [进行中...] 测试执行
🧪 [✅ 通过] 测试执行 - 所有测试通过

🔧 [进行中...] CLI 补全检查
🔧 [✅ 通过] CLI 补全检查 - 补全脚本完整

🔨 [进行中...] 编译验证
🔨 [✅ 通过] 编译验证 - 代码编译成功

🎉 [✅ 完成] 所有必要检查已通过！
```

### 📊 版本检查（功能性变更时）

```bash
# 🔍 检查是否需要更新版本号
grep -r "version.*=" internal/cli/ cmd/workflow/ | head -3

# 📚 验证 CHANGELOG.md 是否已更新
head -30 CHANGELOG.md
```

### 📊 检查优先级和状态

#### 🚨 P0 必须完成项（阻止提交）

| 检查项 | 状态 | 预计时间 | 检查命令 |
|--------|------|----------|----------|
| 🎨 代码质量检查 | `[ 待检查 ]` | ⏱️ 1-2分钟 | `make lint` |
| 🧪 测试通过 | `[ 待检查 ]` | ⏱️ 2-5分钟 | `make test` |
| 🔧 CLI 测试 | `[ 待检查 ]` | ⏱️ 1分钟 | `go test ./internal/cli/...` |
| 🔨 编译通过 | `[ 待检查 ]` | ⏱️ 1分钟 | `go build ./...` |
| 📊 版本检查* | `[ 待检查 ]` | ⏱️ 1分钟 | 手动检查 |

> 💡 **状态说明**：`[ 待检查 ]` → `[ 进行中... ]` → `[ ✅ 通过 ]` / `[ ❌ 失败 ]`

#### ⚠️ P1 建议完成项（提升质量）

| 检查项 | 状态 | 预计时间 | 参考文档 |
|--------|------|----------|----------|
| 📚 文档更新 | `[ 待检查 ]` | ⏱️ 5-10分钟 | [文档检查](#-文档检查) |
| 🔧 CLI 命令注册 | `[ 待检查 ]` | ⏱️ 2-5分钟 | [CLI 检查](#-cli-和-completion-检查) |
| 🧪 基本测试用例 | `[ 待检查 ]` | ⏱️ 5-15分钟 | [测试检查](#-测试用例检查) |

#### 💡 P2 可选完成项（长期改进）

| 检查项 | 状态 | 预计时间 | 参考文档 |
|--------|------|----------|----------|
| 🔍 代码优化 | `[ 可选 ]` | ⏱️ 15-30分钟 | [代码优化检查](#-代码优化检查) |
| 📊 测试覆盖率提升 | `[ 可选 ]` | ⏱️ 10-30分钟 | [测试检查](#-测试用例检查) |
| ⚡ 性能优化 | `[ 可选 ]` | ⏱️ 15-60分钟 | [性能检查](#64-性能检查) |

#### 📊 状态图例

```
🟢 [ ✅ 通过 ]     - 检查成功完成
🔴 [ ❌ 失败 ]     - 检查失败，需要修复
🟡 [ ⚠️ 警告 ]     - 有问题但不阻止提交
🔵 [ 进行中... ]   - 正在执行检查
⚪ [ 待检查 ]      - 尚未开始检查
⚫ [ 已跳过 ]      - 已跳过此检查
💡 [ 可选 ]       - 可选检查项
```

> 💡 **说明**：*版本检查仅在包含新功能（feat）、bug修复（fix）或破坏性变更时需要

---

## ❓ 常见问题

### Q: 如何判断是否需要更新版本号？

**A**: 按照以下规则判断：
- ✅ **需要更新**：新功能（feat）、bug 修复（fix）、性能优化（perf）、破坏性变更（BREAKING CHANGE）
- ❌ **不需要更新**：文档更新（docs）、代码风格（style）、测试（test）、构建/工具（chore、ci）、不影响用户的重构（refactor）

**快速检查命令**：
```bash
# 检查当前分支的提交类型
git log master..HEAD --oneline

# 检查是否有功能性变更
git diff master --stat
```

### Q: Go 项目中版本号如何管理？

**A**: Go 项目通常在代码中定义版本号，有以下方式：

```bash
# 方法 1：在代码中定义版本常量（推荐）
# internal/cli/root.go 或 cmd/workflow/main.go
var version = "1.0.0"

# 方法 2：使用构建标志传递版本
go build -ldflags "-X main.version=1.0.0" ./cmd/workflow

# 方法 3：使用 Git 标签作为版本
git tag -l | tail -1
```

### Q: 如何快速检查所有项？

**A**: 运行 `make lint && make test`，然后手动检查文档和测试覆盖率。

### Q: 补全脚本测试失败怎么办？

**A**: 检查 `internal/cli/` 中的命令结构，确保所有命令都已正确注册。运行 `go run ./cmd/workflow completion generate` 手动生成补全脚本验证。

### Q: 如何提取共用代码？

**A**: 参考 [代码检查指南](../references/review-code.md) 获取详细的提取方法和示例：
- 使用嵌入结构体（embedded struct）提取共用参数
- 创建 `helpers.go` 模块提取共用工具函数（如适用）
- 使用 `fmt.Errorf` 和 `%w` 动词统一错误处理
- 检查 10 种重复代码模式（文件操作、Git 命令、错误处理等）

### Q: 如何进行详细的测试用例检查？

**A**: 参考 [测试用例检查指南](../references/review-test-case.md) 获取完整的检查方法：
- 测试覆盖情况分析（模块覆盖、功能覆盖、覆盖率评估）
- 测试用例合理性检查（测试工具使用、测试结构、测试内容）
- 缺失测试用例识别（缺失模块测试、缺失功能测试、缺失测试类型）

### Q: 如何进行详细的文档检查？

**A**: 参考 [文档完整性检查指南](../references/review-document-completeness.md) 获取完整的检查流程：
- README.md、docs/ 目录和 CHANGELOG.md 的系统化检查
- 重复内容检查（跨文档重复、文档内部重复）
- 文档位置检查和文档优化补全检查

### Q: 文档更新优先级？

**A**: 优先更新 README.md 和相关的命令架构文档，其他文档可以后续补充。详细检查方法请参考 [文档完整性检查指南](../references/review-document-completeness.md)。

### Q: 如何验证补全脚本？

**A**:
1. 运行 `go test ./internal/cli/...` 验证 CLI 测试
2. 运行 `go run ./cmd/workflow completion generate` 生成补全脚本
3. 手动测试补全功能（在 shell 中按 Tab 键）

### Q: 代码优化是必须的吗？

**A**: 不是必须的，但强烈建议。代码优化可以提高代码质量、可维护性和可读性。如果时间紧迫，可以先完成 P0 和 P1 项，P2 项可以后续优化。

---

## 📝 提交前最终检查

在提交代码前，确认以下所有项：

- [ ] 所有 P0 检查项已通过
- [ ] 代码已格式化（`go fmt ./...`）
- [ ] 测试全部通过（`go test ./...`）
- [ ] 文档已更新
- [ ] 提交信息清晰且符合规范
- [ ] 已推送到远程分支
- [ ] PR 描述完整（如适用）

---

**完成以上检查后，代码即可提交！** 🎉

---

## 📚 相关文档

- [综合深入检查指南](./review.md) - 功能完成后、定期审查的深入检查流程
- [快速参考指南](../references/quick-reference.md) - 快速查找命令和清单
- [CLI 检查指南](../references/review-cli.md) - CLI 命令结构、补全脚本检查
- [代码检查指南](../references/review-code.md) - 重复代码、工具复用、第三方库检查
- [测试用例检查指南](../references/review-test-case.md) - 测试覆盖、合理性、缺失测试检查
- [文档完整性检查指南](../references/review-document-completeness.md) - README、架构文档、CHANGELOG 完整性检查
- [架构文档与代码一致性检查指南](../references/review-architecture-consistency.md) - 架构文档与代码一致性检查

---

**最后更新**: 2025-12-28
